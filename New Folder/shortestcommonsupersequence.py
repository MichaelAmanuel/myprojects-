# -*- coding: utf-8 -*-
"""shortestCommonSupersequence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19590nUeYrPa7so5J0zjWB7OKAA9eMkyU
"""

class Solution(object):
    def shortestCommonSupersequence(self, str1, str2):
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m):
            for j in range(n):
                if str1[i] == str2[j]:
                    dp[i + 1][j + 1] = dp[i][j] + 1
                else:
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])

        i, j = m, n
        res = []

        while i > 0 or j > 0:
            if i > 0 and dp[i][j] == dp[i - 1][j]:
                res.append(str1[i - 1])
                i -= 1
            elif j > 0 and dp[i][j] == dp[i][j - 1]:
                res.append(str2[j - 1])
                j -= 1
            else:
                res.append(str1[i - 1])
                i -= 1
                j -= 1

        return "".join(res[::-1])

class Solution(object):
    def lenLongestFibSubseq(self, arr):
        index = {x: i for i, x in enumerate(arr)}
        n = len(arr)
        dp = {}
        max_len = 0

        for k in range(n):
            for j in range(k):
                i = index.get(arr[k] - arr[j])
                if i is not None and i < j:
                    dp[j, k] = dp.get((i, j), 2) + 1
                    max_len = max(max_len, dp[j, k])

        return max_len if max_len >= 3 else 0

